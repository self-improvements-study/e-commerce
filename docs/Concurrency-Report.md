# 1. 📌 목적
- 시스템 내에서 발생할 수 있는 데이터 동시성 문제를 해결하기 위해 적절한 DB Lock 전략을 분석 및 적용하고,<br>
  현재(AS-IS) 방식과 개선안(TO-BE)을 비교하여 데이터 일관성 확보를 위한 방안을 제시하는 데 목적이 있습니다.

<br>

# 2. 🔍 문제 식별
- 동시성 이슈를 식별함에 있어, 기능 단위보다는 **공유 자원(Resource)** 을 기준으로 접근하는 것이 더 효과적이라 판단하였습니다.<br>
  이유는 동시성 문제는 특정 API나 기능 자체에서 발생 하기보다는, 여러 트랜잭션이 동일한 자원에 동시에 접근하거나 변경을 시도할 때 발생하기 때문입니다.

## 2-1 💰 포인트 - 충전 및 차감
- 여러 사용자가 동시에 포인트를 충전하거나 사용할 경우, 정합성 문제가 발생할 수 있습니다.
- 예를 들어, A 사용자가 결제 중 포인트를 차감하고 있고, 동시에 B 프로세스에서 포인트를 충전하거나 다시 차감하게 되면, 최종 포인트 잔액이 잘못 저장될 수 있습니다.

## 2-2 🎟️ 쿠폰 - 선착순 발급
- 제한된 수량의 쿠폰을 여러 사용자가 동시에 발급 요청할 경우, 중복 발급 또는 발급 한도 초과 문제가 발생할 수 있습니다.
- 쿠폰 수량 제한이 있으면 쿠폰 재고를 정확히 관리하기 위한 동시성 제어가 필요합니다.

## 2-3 📦 상품 - 주문
- 사용자가 동시에 같은 상품의 동일한 옵션을 주문하는 경우, 재고 수량 감소 로직에서 재고 수량이 음수가 되거나 중복 주문이 발생할 수 있습니다.
- 특히 인기 상품일 경우 대량 동시 요청이 몰릴 수 있어, 재고 감소를 안전하게 처리하기 위한 락 전략이 필요합니다.

## 2-4 📋 주문 상태 - 결제 대기 및 취소
- 사용자가 주문 후 결제하지 않은 상태로 남아있는 주문은, 스케줄러에 의해 일정 시간이 지나면 자동으로 취소됩니다.<br>
  하지만 동일한 주문에 대해 스케줄러가 상태를 취소로 변경하는 시점과 사용자가 실제 결제를 진행하여 상태를 결제 완료로 바꾸는 시점이 겹칠 경우,<br>
  상태 불일치 혹은 결제 처리 후 주문이 취소되는 등의 정합성 문제가 발생할 수 있습니다.<br>
  따라서, 주문 상태 변경 로직에도 동시성 제어가 필요하며, 이를 위해 상태 기반 조건 업데이트나 락을 활용하는 것이 안전합니다.

## 2-5 ⏳ 쿠폰 - 만료 처리
- 사용자에게 발급된 쿠폰이 일정 기간 동안 사용되지 않을 경우, 스케줄러에 의해 자동 만료 처리됩니다.<br>
  하지만 이 시점과 사용자가 결제를 통해 쿠폰을 사용하는 시점이 겹치게 되면,<br>
  이미 사용된 쿠폰을 만료시키거나, 반대로 만료된 쿠폰이 사용되는 문제가 발생할 수 있습니다.<br>
  이러한 충돌을 방지하기 위해, 쿠폰 상태를 조건으로 하는 업데이트 또는 비관적/낙관적 락을 적용하여<br>
  스케줄러와 사용자 간의 충돌 없이 상태 전이를 안전하게 처리해야 합니다.

<br>

# 3. 🧠 분석

## 3-1 💰 포인트 - 충전 및 차감
- 원인 분석<br>-여러 트랜잭션이 동시에 동일한 사용자의 포인트 정보를 수정할 경우, 최종 포인트 잔액이 잘못 계산되거나 정합성 오류가 발생할 수 있습니다.<br>특히 결제 시 포인트 차감과 동시에, 다른 프로세스에서 포인트를 충전하거나 다시 차감하는 경우에 충돌 가능성이 존재합니다.
- AS-IS 방식의 문제<br>-현재 시스템은 아래와 같은 흐름으로 동작합니다.<br>포인트 잔액 조회 (SELECT) → 포인트 차감/충전 처리 (UPDATE) <br>이 방식에서는 포인트 데이터를 변경하기 전까지의 공백 시간 동안 다른 트랜잭션도 동일 포인트 데이터를 수정할 수 있어,
- 적합한 락 전략<br>- 비관적 락 : 비관적 락은 동시 접근을 완전히 막는 방식이지만, 불필요한 대기와 데드락 가능성, 성능 저하를 초래할 수 있습니다.<br>- 낙관적 락 : 포인트 변경은 일반적으로 충돌 가능성이 낮고 재시도가 가능한 영역이기 때문에, 낙관적 락을 적용하면 성능을 유지하면서도 정합성을 확보할 수 있습니다.

## 3-2 🎟️ 쿠폰 - 선착순 발급
- 원인 분석<br>- 쿠폰 발급은 제한된 수량을 여러 사용자가 동시에 발급 요청할 경우, 발급 한도 초과, 중복 발급 등의 문제가 발생할 수 있습니다.
- AS-IS 방식의 문제<br>- 현재 시스템에서는 쿠폰 재고 SELECT → 발급 INSERT 형식으로 동작하지만, 쿠폰 재고를 차감하는 과정에서 락을 걸지 않으면 여러 요청이 동시에 처리될 수 있어 재고 수량을 초과 발급하는 문제가 발생할 수 있습니다.
- 적합한 락 전략<br>- 비관적 락 : 선착순 쿠폰 발급의 특성상, 여러 사용자가 동시에 쿠폰 발급을 시도할 때, 중복 발급이나 발급 한도 초과 문제가 발생할 수 있습니다. 이를 해결하기 위해 SELECT FOR UPDATE를 사용하여 쿠폰 재고를 잠그고, 트랜잭션이 완료될 때까지 다른 사용자가 발급을 받지 못하도록 할 수 있습니다.<br>- 낙관적 락 : 쿠폰 발급과 같은 선착순 방식에서는 데이터 충돌을 예상하기 어려운 상황이므로, 낙관적 락은 부적합한거 같습니다.

## 3-3 📦 상품 - 주문
- 원인 분석<br>-여러 사용자가 동시에 같은 상품의 동일한 옵션을 주문할 경우, 재고 수량 감소 로직에서 중복 주문이 발생하거나, 재고 수량이 음수가 될 수 있습니다.
- AS-IS 방식의 문제<br>- 재고 감소 처리 시 락을 사용하지 않으면 여러 요청이 동시에 처리되어 Race Condition이 발생할 수 있습니다.
- 적합한 락 전략<br>- 낙관적 락을 사용하면 충돌 발생 시 예외 처리가 필요해 관리가 복잡해지고, 주문 처리가 지연될 수 있으므로, 비관적 락 을 사용하여 재고 수량을 SELECT FOR UPDATE로 잠그는 방식이 적합 할거 같습니다.

## 3-4 📋 주문 상태 - 결제 대기 및 취소
- 원인 분석<br>- 사용자가 주문만 하고 결제를 하지 않는 경우, 결제 대기(PAYMENT_WAITING) 상태로 남아 있습니다.<br>이 상태의 주문은 일정 시간(예: 5분) 내 결제가 되지 않으면 시스템이 자동으로 취소해야 합니다.<br>그런데 동시에 사용자가 결제를 시도하고, 스케줄러가 상태를 CANCELED로 바꾸는 상황이 발생할 수 있어 동시성 충돌 가능성이 있습니다.
- AS-IS 방식의 문제<br>- 결제 API와 스케줄러 모두 Order.status를 변경합니다.<br>별도의 락 처리 없이 업데이트가 이뤄지면, 사용자는 결제를 완료했지만 주문이 취소 처리되는 문제가 발생할 수 있습니다.
- 적합한 락 전략<br>- 낙관적 락: @Version 필드를 활용해 주문 상태 업데이트 시 충돌을 감지하고, 스케줄러가 충돌되면 skip하도록 설계하는 방식이 적합 할거 같습니다.

## 3-5 ⏳ 쿠폰 - 만료 처리
- 원인 분석<br>- 발급된 쿠폰은 유효기간이 존재하고, 유효기간이 지나면 자동으로 만료 처리되어야 합니다.<br>그런데 동시에 사용자가 쿠폰을 사용하는 시도와, 스케줄러가 만료 처리하는 작업이 겹치면 충돌 가능성이 있습니다.
- AS-IS 방식의 문제<br>- 쿠폰 만료 처리 스케줄러가 별도 락 없이 쿠폰 상태를 EXPIRED로 변경합니다.<br>동시에 사용자 결제 로직에서 쿠폰을 USED로 변경하려고 하면, 데이터 정합성 문제 발생 가능성이 있습니다.
- 적합한 락 전략<br>- 낙관적 락: @Version 필드를 사용하여, 쿠폰 상태 변경 시 스케줄러가 충돌되면 skip하도록 설계하는 방식이 적합 할거 같습니다.



<br>

# 4. ✅ 해결 방안

## 4-1 💰 포인트 - 충전 및 차감
- @Version 필드를 활용한 낙관적 락 적용

```java
@Entity
@Table(name = "point")
public class Point extends AuditableEntity {
    @Version
    private Long version;
}
```

- 포인트 충전 및 차감 시, 버전을 비교하여 충돌이 발생하면 예외 발생 → 재시도 전략 적용
- 재시도에도 실패할 경우 BusinessError.CONCURRENCY_FAILURE 예외를 발생시켜, 클라이언트에 명확한 원인을 전달한다.
- 충돌 가능성이 낮고 사용자 단위 트랜잭션이 많기 때문에 성능과 정합성의 균형을 유지할 수 있습니다.

## 4-2 🎟️ 쿠폰 - 선착순 발급
- SELECT ... FOR UPDATE 를 활용한 비관적 락 적용

```java
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT p FROM Coupon p WHERE p.id = :id")
    Optional<Coupon> findCouponByUserIdForUpdate(@Param("id") Long id);
```

- 발급 요청 시 쿠폰 재고를 조회하고 해당 행을 즉시 잠금 처리하여, 다른 트랜잭션의 동시 접근을 차단
- 쿠폰 재고 감소 후, 발급 데이터를 INSERT → 트랜잭션 종료 시까지 락 유지
- 중복 발급 방지 및 재고 초과 방지에 효과적이라고 판단 됩니다.

## 4-3 📦 상품 - 주문
- SELECT ... FOR UPDATE 를 사용하여 비관적 락 적용

```java
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT s FROM Stock s WHERE s.productOptionId IN :optionIds ORDER BY s.productOptionId")
    List<Stock> findByProductOptionIdInWithLock(@Param("optionIds") List<Long> optionIds);
```

- 주문 요청 시 해당 상품 옵션의 재고를 먼저 잠그고, 차감 처리
- 트랜잭션 종료 후 락 해제 → 재고의 정합성을 보장

## 4-4 📋 주문 상태 - 결제 대기 및 취소
- @Version 필드를 활용한 낙관적 락 적용

```java
@Entity
@Table(name = "order")
public class Order extends AuditableEntity {
    @Version
    private Long version;
}
```
- 사용자가 결제를 진행 중인 상태에서 스케줄러 또는 타 프로세스가 주문 상태를 취소하려는 경우, 충돌을 감지할 수 있도록 @Version을 활용 합니다.
- 충돌 발생 시 스케줄러는 해당 주문을 스킵 합니다.
## 4-5 ⏳ 쿠폰 - 만료 처리
- @Version 필드를 활용한 낙관적 락 적용

```java
@Entity
@Table(name = "user_coupon")
public class UserCoupon extends AuditableEntity {
    @Version
    private Long version;
}
```
- 쿠폰 만료 스케줄러가 동작 중일 때, 사용자가 쿠폰을 사용하는 경우를 대비하여 낙관적 락을 통해 충돌 감지 합니다.
- 충돌이 발생하면 재시도 없이 스킵 합니다.

<br>

# 5. 💡 대안
- DB 락 기반 해결 외에도 시스템 구조 또는 아키텍처 개선을 통해 동시성 문제를 완화할 수 있는 여러 대안들이 존재합니다.

## 5-1 분산 락 (Distributed Lock)
- 설명: Redis, ZooKeeper, etcd 등의 외부 시스템을 사용하여 분산 환경에서도 동시성 제어
- 활용 예시: Redis의 Redisson 라이브러리를 활용한 분산 락 구현<br>쿠폰 발급이나 재고 감소 같은 핵심 자원 보호에 적합
- 장점: DB 락과 무관하게 처리 가능, 수평 확장에 유리
- 단점: 네트워크 이슈로 인한 신뢰성 보장 어려움, 별도 인프라 필요
## 5-2 이벤트 큐 (Event Queue) 기반 직렬 처리
- 설명: Kafka, RabbitMQ 등의 메시지 큐를 활용해 요청을 순차적으로 처리
- 활용 예시: 상품 주문, 쿠폰 발급 등의 요청을 큐에 적재하고 소비자가 순차 처리
- 장점: 락이 불필요하고 처리 순서를 제어 가능, 확장성 우수
- 단점: 실시간 응답이 어렵고 지연 발생 가능, 구현 복잡도 증가
## 5-3 DB Trigger 또는 저장 프로시저
- 설명: DB 내부에서 정합성 제어를 위해 트리거나 프로시저 작성
- 활용 예시: 쿠폰 재고 차감을 프로시저 내에서만 수행하고 외부 트랜잭션은 접근 차단
- 장점: DB 일관성을 강력하게 보장
- 단점: 유지보수 어려움, 복잡한 비즈니스 로직에는 부적합
## 5-4 분산 캐시 + 비동기 일괄 처리
- 설명: 요청을 일단 캐시에 반영한 뒤 비동기로 DB에 반영
- 활용 예시: 포인트 잔액을 Redis에 우선 반영하고 일정 주기로 DB 동기화
- 장점: 성능 극대화
- 단점: 데이터 정합성 보장 어려움, 충돌 시 복구 로직 필요